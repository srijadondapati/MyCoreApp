parameters:
  environmentName: ''

jobs:
- job: Tag_Work_Items
  displayName: 'Tag work items: ${{ parameters.environmentName }}'
  pool:
    vmImage: ubuntu-latest

  steps:
  - powershell: |
      $org = "$(ADO_ORG)"
      $project = "$(ADO_PROJECT)"
      $envTag = "DevOpsDeployed:${{ parameters.environmentName }}"
      
      $pat = "$(ADO_PAT)"
      if ([string]::IsNullOrWhiteSpace($pat)) {
        throw "ADO_PAT is missing"
      }

      # Base64 Auth
      $basicAuth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
      $headers = @{ Authorization = "Basic $basicAuth" }

      # --- LOGIC FIX 1: Use Build API instead of Commit Message ---
      # This is 100% reliable. Even if PR is squashed, this works.
      $buildId = "$(Build.BuildId)"
      $wiApiUrl = "https://dev.azure.com/$org/$project/_apis/build/builds/$buildId/workitems?api-version=7.1"
      
      Write-Host "Fetching Work Items for Build ID: $buildId"
      try {
        $wiResponse = Invoke-RestMethod -Uri $wiApiUrl -Method Get -Headers $headers
        $ids = $wiResponse.value.id
      }
      catch {
        Write-Warning "Could not fetch work items from API. Falling back to commit message..."
        # Fallback to your regex method ONLY if API fails
        $commitMsg = "$(Build.SourceVersionMessage)"
        $ids = [regex]::Matches($commitMsg, 'AB#(\d+)') | ForEach-Object { $_.Groups[1].Value } | Select-Object -Unique
      }

      if (-not $ids -or $ids.Count -eq 0) {
        Write-Host "No work item IDs found. Skipping."
        exit 0
      }

      Write-Host "Found IDs: $($ids -join ', ')"

      foreach ($id in $ids) {
        Write-Host "Processing Work Item $id" # --- LOGIC FIX 2: Moved inside loop
        
        $url = "https://dev.azure.com/$org/$project/_apis/wit/workitems/$id?api-version=7.1"

        # Get existing tags
        $wi = Invoke-RestMethod -Method Get -Uri $url -Headers $headers
        $existing = $wi.fields.'System.Tags'
        if (-not $existing) { $existing = "" }

        $tags = $existing -split ';' | ForEach-Object { $_.Trim() }
        if ($tags -contains $envTag) {
          Write-Host "Tag already exists on $id"
          continue
        }

        $newTags = if ($existing) { "$existing; $envTag" } else { $envTag }

        # --- LOGIC FIX 3: Use 'replace' not 'add' ---
        $body = @(
          @{
            op = "replace" # <--- CHANGED FROM 'add'
            path = "/fields/System.Tags"
            value = $newTags
          }
        ) | ConvertTo-Json

        Invoke-RestMethod `
          -Method Patch `
          -Uri $url `
          -Headers $headers `
          -Body $body `
          -ContentType "application/json-patch+json"

        Write-Host "Updated $id with tag $envTag"
      }
    displayName: 'Update ADO work item tags'
    continueOnError: true # Don't fail pipeline if tagging fails