parameters:
- name: environmentName
  type: string

- name: dependsOnJob
  type: string

jobs:
- job: Tag_Work_Items_${{ parameters.environmentName }}
  displayName: Tag Work Items - ${{ parameters.environmentName }}
  dependsOn: ${{ parameters.dependsOnJob }}
  condition: succeeded()

  steps:
  - checkout: self

  - task: PowerShell@2
    displayName: Update ADO work item tags
    inputs:
      targetType: inline
      pwsh: true
      script: |
        Write-Host "Starting work item tagging for environment: ${{ parameters.environmentName }}"

        # ==========================
        # Read variables
        # ==========================
        $org     = "$(ADO_ORG)"       # Example: ProjectSR   (ORG name only)
        $pat     = "$(ADO_PAT)"
        $envName = "${{ parameters.environmentName }}"
        $apiVersion = "7.1-preview.3"

        if ([string]::IsNullOrWhiteSpace($org) -or [string]::IsNullOrWhiteSpace($pat)) {
          Write-Error "Missing required variables: ADO_ORG and/or ADO_PAT."
          exit 1
        }

        # ==========================
        # Auth header (PAT)
        # ==========================
        $base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
        $authHeader = @{ Authorization = "Basic $base64Auth" }

        # ==========================
        # Read commit message
        # ==========================
        $commitMessage = git log -1 --pretty=%B
        Write-Host "Commit message: $commitMessage"

        # ==========================
        # Extract AB#123 IDs
        # ==========================
        $workItemIds =
          [regex]::Matches($commitMessage, 'AB#(\d+)') |
          ForEach-Object { $_.Groups[1].Value } |
          Where-Object { $_ -match '^\d+$' } |
          Select-Object -Unique

        if (-not $workItemIds -or $workItemIds.Count -eq 0) {
          Write-Host "No work item IDs found. Skipping."
          exit 0
        }

        foreach ($id in $workItemIds) {

          Write-Host "Processing Work Item: [$id]"

          # IMPORTANT:
          # Use ORG-scoped endpoint (no project segment) to avoid 404 when project name differs.
          $url = "https://dev.azure.com/$org/_apis/wit/workitems/$($id)?api-version=$apiVersion"
          Write-Host "GET: $url"

          try {
            $wi = Invoke-RestMethod -Method Get -Uri $url -Headers $authHeader -ErrorAction Stop
          } catch {
            Write-Error "Failed to fetch work item $id. HTTP error: $($_.Exception.Message)"
            exit 1
          }

          $existingTags = $wi.fields.'System.Tags'
          $newTag = "DevOpsDeployed:$envName"

          if ($existingTags -and $existingTags -like "*$newTag*") {
            Write-Host "Tag already exists for $id: $newTag"
            continue
          }

          $updatedTags = if ($existingTags) { "$existingTags;$newTag" } else { $newTag }

          $patchBody = @(
            @{
              op    = "add"
              path  = "/fields/System.Tags"
              value = $updatedTags
            }
          ) | ConvertTo-Json -Depth 5

          Write-Host "PATCH: $url"
          Write-Host "New Tags: $updatedTags"

          try {
            Invoke-RestMethod `
              -Method Patch `
              -Uri $url `
              -Headers @{
                Authorization  = $authHeader.Authorization
                "Content-Type" = "application/json-patch+json"
              } `
              -Body $patchBody `
              -ErrorAction Stop
          } catch {
            Write-Error "Failed to update work item $id. HTTP error: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "Updated work item $id with tag: $newTag"
        }
